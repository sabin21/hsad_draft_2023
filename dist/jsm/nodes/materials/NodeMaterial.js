import{Material,ShaderMaterial}from"three";import{getNodeChildren,getCacheKey}from"../core/NodeUtils.js";import{attribute}from"../core/AttributeNode.js";import{diffuseColor}from"../core/PropertyNode.js";import{materialNormal}from"../accessors/ExtendedMaterialNode.js";import{materialAlphaTest,materialColor,materialOpacity,materialEmissive}from"../accessors/MaterialNode.js";import{modelViewProjection}from"../accessors/ModelViewProjectionNode.js";import{transformedNormalView}from"../accessors/NormalNode.js";import{instance}from"../accessors/InstanceNode.js";import{positionLocal}from"../accessors/PositionNode.js";import{skinning}from"../accessors/SkinningNode.js";import{texture}from"../accessors/TextureNode.js";import{lightsWithoutWrap}from"../lighting/LightsNode.js";import{mix}from"../math/MathNode.js";import{float,vec3,vec4}from"../shadernode/ShaderNode.js";import AONode from"../lighting/AONode.js";import EnvironmentNode from"../lighting/EnvironmentNode.js";const NodeMaterials=new Map;class NodeMaterial extends ShaderMaterial{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.name,this.lights=!0,this.normals=!0,this.lightsNode=null,this.envNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null}customProgramCacheKey(){return getCacheKey(this)}build(t){this.construct(t)}construct(t){t.addStack(),t.stack.outputNode=this.constructPosition(t),t.addFlow("vertex",t.removeStack()),t.addStack(),!0===this.normals&&this.constructNormal(t),this.constructDiffuseColor(t),this.constructVariants(t);const o=this.constructLighting(t);t.stack.outputNode=this.constructOutput(t,o,diffuseColor.a),t.addFlow("fragment",t.removeStack())}constructPosition(t){const o=t.object;let e=positionLocal;return null!==this.positionNode&&(e=e.bypass(positionLocal.assign(this.positionNode))),o.instanceMatrix&&!0===o.instanceMatrix.isInstancedBufferAttribute&&!0===t.isAvailable("instance")&&(e=e.bypass(instance(o))),!0===o.isSkinnedMesh&&(e=e.bypass(skinning(o))),t.context.vertex=e,modelViewProjection()}constructDiffuseColor({stack:t,geometry:o}){let e=this.colorNode?vec4(this.colorNode):materialColor;!0===this.vertexColors&&o.hasAttribute("color")&&(e=vec4(e.xyz.mul(attribute("color")),e.a)),t.assign(diffuseColor,e);const i=this.opacityNode?float(this.opacityNode):materialOpacity;if(t.assign(diffuseColor.a,diffuseColor.a.mul(i)),this.alphaTestNode||this.alphaTest>0){const o=this.alphaTestNode?float(this.alphaTestNode):materialAlphaTest;t.add(diffuseColor.a.lessThanEqual(o).discard())}}constructVariants(){}constructNormal({stack:t}){const o=this.normalNode?vec3(this.normalNode):materialNormal;return t.assign(transformedNormalView,o),o}constructLights(t){const o=this.envNode||t.environmentNode,e=[];o&&e.push(new EnvironmentNode(o)),t.material.aoMap&&e.push(new AONode(texture(t.material.aoMap)));let i=this.lightsNode||t.lightsNode;return e.length>0&&(i=lightsWithoutWrap([...i.lightNodes,...e])),i}constructLightingModel(){}constructLighting(t){const{material:o}=t,{backdropNode:e,backdropAlphaNode:i,emissiveNode:s}=this,r=!0===this.lights||null!==this.lightsNode?this.constructLights(t):null,a=r?this.constructLightingModel(t):null;let n=diffuseColor.rgb;return r&&!1!==r.hasLight?n=r.lightingContext(a,e,i):null!==e&&(n=vec3(null!==i?mix(n,e,i):e)),(s&&!0===s.isNode||o.emissive&&!0===o.emissive.isColor)&&(n=n.add(s?vec3(s):materialEmissive)),n}constructOutput(t,o,e){const i=t.renderer,s=t.toneMappingNode;s&&(o=s.context({color:o}));let r=vec4(o,e);r=r.colorSpace(i.outputColorSpace);const a=t.fogNode;return a&&(r=vec4(a.mixAssign(r.rgb),r.a)),r}setDefaultValues(t){for(const o in t){const e=t[o];void 0===this[o]&&(this[o]=e,e&&e.clone&&(this[o]=e.clone()))}Object.assign(this.defines,t.defines);const o=Object.getOwnPropertyDescriptors(t.constructor.prototype);for(const t in o)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,t)&&void 0!==o[t].get&&Object.defineProperty(this.constructor.prototype,t,o[t])}toJSON(t){const o=void 0===t||"string"==typeof t;o&&(t={textures:{},images:{},nodes:{}});const e=Material.prototype.toJSON.call(this,t),i=getNodeChildren(this);e.inputNodes={};for(const{property:o,childNode:s}of i)e.inputNodes[o]=s.toJSON(t).uuid;function s(t){const o=[];for(const e in t){const i=t[e];delete i.metadata,o.push(i)}return o}if(o){const o=s(t.textures),i=s(t.images),r=s(t.nodes);o.length>0&&(e.textures=o),i.length>0&&(e.images=i),r.length>0&&(e.nodes=r)}return e}static fromMaterial(t){if(!0===t.isNodeMaterial)return t;const o=createNodeMaterialFromType(t.type.replace("Material","NodeMaterial"));if(void 0===o)throw new Error(`NodeMaterial: Material "${t.type}" is not compatible.`);for(const e in t)o[e]=t[e];return o}}export default NodeMaterial;export function addNodeMaterial(t){if("function"!=typeof t||!t.name)throw new Error(`Node material ${t.name} is not a class`);if(NodeMaterials.has(t.name))throw new Error(`Redefinition of node material ${t.name}`);NodeMaterials.set(t.name,t)}export function createNodeMaterialFromType(t){const o=NodeMaterials.get(t);if(void 0!==o)return new o}addNodeMaterial(NodeMaterial);