import ContextNode from"../core/ContextNode.js";import{temp}from"../core/VarNode.js";import{add}from"../math/OperatorNode.js";import{mix}from"../math/MathNode.js";import{addNodeClass}from"../core/Node.js";import{addNodeElement,nodeProxy,float,vec3}from"../shadernode/ShaderNode.js";class LightingContextNode extends ContextNode{constructor(e,t=null,o=null,i=null){super(e),this.lightingModelNode=t,this.backdropNode=o,this.backdropAlphaNode=i}getNodeType(){return"vec3"}construct(e){const{lightingModelNode:t,backdropNode:o,backdropAlphaNode:i}=this,d=this.context={},r=e.getNodeProperties(this),n=temp(vec3()),c=temp(vec3()),l=temp(vec3()),a=temp(vec3());let s=add(n,l);null!==o&&(s=vec3(null!==i?mix(s,o,i):o));const p=add(c,a),g={directDiffuse:n,directSpecular:c,indirectDiffuse:l,indirectSpecular:a,total:add(s,p)},m={radiance:temp(vec3()),irradiance:temp(vec3()),iblIrradiance:temp(vec3()),ambientOcclusion:temp(float(1))};return Object.assign(r,g,m),Object.assign(d,m),d.reflectedLight=g,d.lightingModelNode=t||d.lightingModelNode,t&&t.indirectDiffuse&&t.indirectDiffuse.call(d),t&&t.indirectSpecular&&t.indirectSpecular.call(d),t&&t.ambientOcclusion&&t.ambientOcclusion.call(d),super.construct(e)}generate(e){const{context:t}=this,o=this.getNodeType(e);return super.generate(e,o),t.reflectedLight.total.build(e,o)}}export default LightingContextNode;export const lightingContext=nodeProxy(LightingContextNode);addNodeElement("lightingContext",lightingContext),addNodeClass(LightingContextNode);