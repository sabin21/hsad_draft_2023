import NodeUniform from"./NodeUniform.js";import NodeAttribute from"./NodeAttribute.js";import NodeVarying from"./NodeVarying.js";import NodeVar from"./NodeVar.js";import NodeCode from"./NodeCode.js";import NodeKeywords from"./NodeKeywords.js";import NodeCache from"./NodeCache.js";import{NodeUpdateType,defaultBuildStages,shaderStages}from"./constants.js";import{REVISION,NoColorSpace,LinearEncoding,sRGBEncoding,SRGBColorSpace,Color,Vector2,Vector3,Vector4,Float16BufferAttribute}from"three";import{stack}from"./StackNode.js";import{maxMipLevel}from"../utils/MaxMipLevelNode.js";const typeFromLength=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),typeFromArray=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),isNonPaddingElementArray=new Set([Int32Array,Uint32Array,Float32Array]),toFloat=t=>(t=Number(t))+(t%1?"":".0");class NodeBuilder{constructor(t,e,r){this.object=t,this.material=t&&(t.material||null),this.geometry=t&&(t.geometry||null),this.renderer=e,this.parser=r,this.nodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.hashNodes={},this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.toneMappingNode=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:[]},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.codes={vertex:[],fragment:[],compute:[]},this.attributes=[],this.varyings=[],this.vars={vertex:[],fragment:[],compute:[]},this.flow={code:""},this.chaining=[],this.stack=stack(),this.tab="\t",this.context={keywords:new NodeKeywords,material:this.material,getMIPLevelAlgorithmNode:(t,e)=>e.mul(maxMipLevel(t))},this.cache=new NodeCache,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null}setHashNode(t,e){this.hashNodes[e]=t}addNode(t){if(-1===this.nodes.indexOf(t)){const e=t.getUpdateType(),r=t.getUpdateBeforeType();e!==NodeUpdateType.NONE&&this.updateNodes.push(t),r!==NodeUpdateType.NONE&&this.updateBeforeNodes.push(t),this.nodes.push(t),this.setHashNode(t,t.getHash(this))}}get currentNode(){return this.chaining[this.chaining.length-1]}addChain(t){this.chaining.push(t)}removeChain(t){if(this.chaining.pop()!==t)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(t){return t}getNodeFromHash(t){return this.hashNodes[t]}addFlow(t,e){return this.flowNodes[t].push(e),e}setContext(t){this.context=t}getContext(){return this.context}setCache(t){this.cache=t}getCache(){return this.cache}isAvailable(){return!1}getInstanceIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}getTexture(){console.warn("Abstract function.")}getTextureLevel(){console.warn("Abstract function.")}getConst(t,e=null){if(null===e&&("float"===t||"int"===t||"uint"===t?e=0:"bool"===t?e=!1:"color"===t?e=new Color:"vec2"===t?e=new Vector2:"vec3"===t?e=new Vector3:"vec4"===t&&(e=new Vector4)),"float"===t)return toFloat(e);if("int"===t)return`${Math.round(e)}`;if("uint"===t)return e>=0?`${Math.round(e)}u`:"0u";if("bool"===t)return e?"true":"false";if("color"===t)return`${this.getType("vec3")}( ${toFloat(e.r)}, ${toFloat(e.g)}, ${toFloat(e.b)} )`;const r=this.getTypeLength(t),o=this.getComponentType(t),n=t=>this.getConst(o,t);if(2===r)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)} )`;if(3===r)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)}, ${n(e.z)} )`;if(4===r)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)}, ${n(e.z)}, ${n(e.w)} )`;if(r>4)return`${this.getType(t)}()`;throw new Error(`NodeBuilder: Type '${t}' not found in generate constant attempt.`)}getType(t){return t}generateMethod(t){return t}hasGeometryAttribute(t){return this.geometry&&void 0!==this.geometry.getAttribute(t)}getAttribute(t,e){const r=this.attributes;for(const e of r)if(e.name===t)return e;const o=new NodeAttribute(t,e);return r.push(o),o}getPropertyName(t){return t.name}isVector(t){return/vec\d/.test(t)}isMatrix(t){return/mat\d/.test(t)}isReference(t){return"void"===t||"property"===t||"sampler"===t||"texture"===t||"cubeTexture"===t}isShaderStage(t){return this.shaderStage===t}getTextureEncodingFromMap(t){return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."),this.getTextureColorSpaceFromMap(t)===SRGBColorSpace?sRGBEncoding:LinearEncoding}getTextureColorSpaceFromMap(t){let e;return e=t&&t.isTexture?t.colorSpace:t&&t.isWebGLRenderTarget?t.texture.colorSpace:NoColorSpace,e}getComponentType(t){if("float"===(t=this.getVectorType(t))||"bool"===t||"int"===t||"uint"===t)return t;const e=/(b|i|u|)(vec|mat)([2-4])/.exec(t);return null===e?null:"b"===e[1]?"bool":"i"===e[1]?"int":"u"===e[1]?"uint":"float"}getVectorType(t){return"color"===t?"vec3":"texture"===t?"vec4":t}getTypeFromLength(t,e="float"){if(1===t)return e;const r=typeFromLength.get(t);return("float"===e?"":e[0])+r}getTypeFromArray(t){return typeFromArray.get(t.constructor)}getTypeFromAttribute(t){let e=t;t.isInterleavedBufferAttribute&&(e=t.data);const r=e.array,o=isNonPaddingElementArray.has(r.constructor)?t.itemSize:e.stride||t.itemSize,n=t.normalized;let s;return t instanceof Float16BufferAttribute||!0===n||(s=this.getTypeFromArray(r)),this.getTypeFromLength(o,s)}getTypeLength(t){const e=this.getVectorType(t),r=/vec([2-4])/.exec(e);return null!==r?Number(r[1]):"float"===e||"bool"===e||"int"===e||"uint"===e?1:!0===/mat3/.test(t)?9:!0===/mat4/.test(t)?16:0}getVectorFromMatrix(t){return t.replace("mat","vec")}changeComponentType(t,e){return this.getTypeFromLength(this.getTypeLength(t),e)}getIntegerType(t){const e=this.getComponentType(t);return"int"===e||"uint"===e?t:this.changeComponentType(t,"int")}addStack(){return this.stack=stack(this.stack),this.stack}removeStack(){const t=this.stack;return this.stack=t.parent,t}getDataFromNode(t,e=this.shaderStage){const r=t.isGlobal(this)?this.globalCache:this.cache;let o=r.getNodeData(t);return void 0===o&&(o={vertex:{},fragment:{},compute:{}},r.setNodeData(t,o)),null!==e?o[e]:o}getNodeProperties(t,e=this.shaderStage){const r=this.getDataFromNode(t,e);return r.properties||(r.properties={outputNode:null})}getUniformFromNode(t,e,r){const o=this.getDataFromNode(t,e);let n=o.uniform;if(void 0===n){const s=this.uniforms.index++;n=new NodeUniform("nodeUniform"+s,r,t),this.uniforms[e].push(n),o.uniform=n}return n}getVarFromNode(t,e,r=this.shaderStage){const o=this.getDataFromNode(t,r);let n=o.variable;if(void 0===n){const t=this.vars[r],s=t.length;n=new NodeVar("nodeVar"+s,e),t.push(n),o.variable=n}return n}getVaryingFromNode(t,e){const r=this.getDataFromNode(t,null);let o=r.varying;if(void 0===o){const t=this.varyings,n=t.length;o=new NodeVarying("nodeVarying"+n,e),t.push(o),r.varying=o}return o}getCodeFromNode(t,e,r=this.shaderStage){const o=this.getDataFromNode(t);let n=o.code;if(void 0===n){const t=this.codes[r],s=t.length;n=new NodeCode("nodeCode"+s,e),t.push(n),o.code=n}return n}addLineFlowCode(t){return""===t||(t=this.tab+t,/;\s*$/.test(t)||(t+=";\n"),this.flow.code+=t),this}addFlowCode(t){return this.flow.code+=t,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(t){return this.flowsData.get(t)}flowNode(t){const e=t.getNodeType(this),r=this.flowChildNode(t,e);return this.flowsData.set(t,r),r}flowChildNode(t,e=null){const r=this.flow,o={code:""};return this.flow=o,o.result=t.build(this,e),this.flow=r,o}flowNodeFromShaderStage(t,e,r=null,o=null){const n=this.shaderStage;this.setShaderStage(t);const s=this.flowChildNode(e,r);return null!==o&&(s.code+=`${this.tab+o} = ${s.result};\n`),this.flowCode[t]=this.flowCode[t]+s.code,this.setShaderStage(n),s}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVars(t){let e="";const r=this.vars[t];for(const t of r)e+=`${t.type} ${t.name}; `;return e}getUniforms(){console.warn("Abstract function.")}getCodes(t){const e=this.codes[t];let r="";for(const t of e)r+=t.code+"\n";return r}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(t){this.shaderStage=t}getShaderStage(){return this.shaderStage}setBuildStage(t){this.buildStage=t}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}build(){for(const t of defaultBuildStages){this.setBuildStage(t),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const e of shaderStages){this.setShaderStage(e);const r=this.flowNodes[e];for(const e of r)"generate"===t?this.flowNode(e):e.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this}format(t,e,r){if((e=this.getVectorType(e))===(r=this.getVectorType(r))||null===r||this.isReference(r))return t;const o=this.getTypeLength(e),n=this.getTypeLength(r);return o>4||n>4||0===n?t:o===n?`${this.getType(r)}( ${t} )`:o>n?this.format(`${t}.${"xyz".slice(0,n)}`,this.getTypeFromLength(n,this.getComponentType(e)),r):4===n?`${this.getType(r)}( ${this.format(t,e,"vec3")}, 1.0 )`:2===o?`${this.getType(r)}( ${this.format(t,e,"vec2")}, 0.0 )`:`${this.getType(r)}( ${t} )`}getSignature(){return`// Three.js r${REVISION} - NodeMaterial System\n`}}export default NodeBuilder;