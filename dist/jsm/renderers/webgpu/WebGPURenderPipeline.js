import{GPUIndexFormat,GPUCompareFunction,GPUFrontFace,GPUCullMode,GPUBlendFactor,GPUBlendOperation,BlendColorFactor,OneMinusBlendColorFactor,GPUColorWriteFlags,GPUStencilOperation,GPUInputStepMode}from"./constants.js";import{Float16BufferAttribute,FrontSide,BackSide,DoubleSide,NeverDepth,AlwaysDepth,LessDepth,LessEqualDepth,EqualDepth,GreaterEqualDepth,GreaterDepth,NotEqualDepth,NeverStencilFunc,AlwaysStencilFunc,LessStencilFunc,LessEqualStencilFunc,EqualStencilFunc,GreaterEqualStencilFunc,GreaterStencilFunc,NotEqualStencilFunc,KeepStencilOp,ZeroStencilOp,ReplaceStencilOp,InvertStencilOp,IncrementStencilOp,DecrementStencilOp,IncrementWrapStencilOp,DecrementWrapStencilOp,NoBlending,NormalBlending,AdditiveBlending,SubtractiveBlending,MultiplyBlending,CustomBlending,AddEquation,SubtractEquation,ReverseSubtractEquation,MinEquation,MaxEquation,ZeroFactor,OneFactor,SrcColorFactor,OneMinusSrcColorFactor,SrcAlphaFactor,OneMinusSrcAlphaFactor,DstAlphaFactor,OneMinusDstAlphaFactor,DstColorFactor,OneMinusDstColorFactor,SrcAlphaSaturateFactor}from"three";const typedArraysToVertexFormatPrefix=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]),typedAttributeToVertexFormatPrefix=new Map([[Float16BufferAttribute,["float16"]]]),typeArraysToVertexFormatPrefixForItemSize1=new Map([[Int32Array,"sint32"],[Uint32Array,"uint32"],[Float32Array,"float32"]]);class WebGPURenderPipeline{constructor(e,t){this.cacheKey=null,this.shaderAttributes=null,this.stageVertex=null,this.stageFragment=null,this.usedTimes=0,this._device=e,this._utils=t}init(e,t,r,a,n){const{object:o,material:c,geometry:l}=a,i=this._getShaderAttributes(n,l),s=[];for(const e of i){const t=e.name,r=l.getAttribute(t),a=void 0!==r&&r.isInstancedBufferAttribute?GPUInputStepMode.Instance:GPUInputStepMode.Vertex;s.push({arrayStride:e.arrayStride,attributes:[{shaderLocation:e.slot,offset:e.offset,format:e.format}],stepMode:a})}this.cacheKey=e,this.shaderAttributes=i,this.stageVertex=t,this.stageFragment=r;let d={},u={};!0===c.transparent&&c.blending!==NoBlending&&(d=this._getAlphaBlend(c),u=this._getColorBlend(c));let p={};!0===c.stencilWrite&&(p={compare:this._getStencilCompare(c),failOp:this._getStencilOperation(c.stencilFail),depthFailOp:this._getStencilOperation(c.stencilZFail),passOp:this._getStencilOperation(c.stencilZPass)});const F=this._getPrimitiveState(o,l,c),P=this._getColorWriteMask(c),G=this._getDepthCompare(c),S=this._utils.getCurrentColorFormat(),h=this._utils.getCurrentDepthStencilFormat(),U=this._utils.getSampleCount();this.pipeline=this._device.createRenderPipeline({vertex:Object.assign({},t.stage,{buffers:s}),fragment:Object.assign({},r.stage,{targets:[{format:S,blend:{alpha:d,color:u},writeMask:P}]}),primitive:F,depthStencil:{format:h,depthWriteEnabled:c.depthWrite,depthCompare:G,stencilFront:p,stencilBack:{},stencilReadMask:c.stencilFuncMask,stencilWriteMask:c.stencilWriteMask},multisample:{count:U},layout:"auto"})}_getAlphaBlend(e){const t=e.blending,r=e.premultipliedAlpha;let a;switch(t){case NormalBlending:!1===r&&(a={srcFactor:GPUBlendFactor.One,dstFactor:GPUBlendFactor.OneMinusSrcAlpha,operation:GPUBlendOperation.Add});break;case AdditiveBlending:a={srcFactor:GPUBlendFactor.Zero,dstFactor:GPUBlendFactor.One,operation:GPUBlendOperation.Add};break;case SubtractiveBlending:!0===r&&(a={srcFactor:GPUBlendFactor.OneMinusSrcColor,dstFactor:GPUBlendFactor.OneMinusSrcAlpha,operation:GPUBlendOperation.Add});break;case MultiplyBlending:!0===r&&(a={srcFactor:GPUBlendFactor.Zero,dstFactor:GPUBlendFactor.SrcAlpha,operation:GPUBlendOperation.Add});break;case CustomBlending:const n=e.blendSrcAlpha,o=e.blendDstAlpha,c=e.blendEquationAlpha;null!==n&&null!==o&&null!==c&&(a={srcFactor:this._getBlendFactor(n),dstFactor:this._getBlendFactor(o),operation:this._getBlendOperation(c)});break;default:console.error("THREE.WebGPURenderer: Blending not supported.",t)}return a}_getBlendFactor(e){let t;switch(e){case ZeroFactor:t=GPUBlendFactor.Zero;break;case OneFactor:t=GPUBlendFactor.One;break;case SrcColorFactor:t=GPUBlendFactor.SrcColor;break;case OneMinusSrcColorFactor:t=GPUBlendFactor.OneMinusSrcColor;break;case SrcAlphaFactor:t=GPUBlendFactor.SrcAlpha;break;case OneMinusSrcAlphaFactor:t=GPUBlendFactor.OneMinusSrcAlpha;break;case DstColorFactor:t=GPUBlendFactor.DstColor;break;case OneMinusDstColorFactor:t=GPUBlendFactor.OneMinusDstColor;break;case DstAlphaFactor:t=GPUBlendFactor.DstAlpha;break;case OneMinusDstAlphaFactor:t=GPUBlendFactor.OneMinusDstAlpha;break;case SrcAlphaSaturateFactor:t=GPUBlendFactor.SrcAlphaSaturated;break;case BlendColorFactor:t=GPUBlendFactor.BlendColor;break;case OneMinusBlendColorFactor:t=GPUBlendFactor.OneMinusBlendColor;break;default:console.error("THREE.WebGPURenderer: Blend factor not supported.",e)}return t}_getBlendOperation(e){let t;switch(e){case AddEquation:t=GPUBlendOperation.Add;break;case SubtractEquation:t=GPUBlendOperation.Subtract;break;case ReverseSubtractEquation:t=GPUBlendOperation.ReverseSubtract;break;case MinEquation:t=GPUBlendOperation.Min;break;case MaxEquation:t=GPUBlendOperation.Max;break;default:console.error("THREE.WebGPURenderer: Blend equation not supported.",e)}return t}_getColorBlend(e){const t=e.blending,r=e.premultipliedAlpha,a={srcFactor:null,dstFactor:null,operation:null};switch(t){case NormalBlending:a.srcFactor=!0===r?GPUBlendFactor.One:GPUBlendFactor.SrcAlpha,a.dstFactor=GPUBlendFactor.OneMinusSrcAlpha,a.operation=GPUBlendOperation.Add;break;case AdditiveBlending:a.srcFactor=!0===r?GPUBlendFactor.One:GPUBlendFactor.SrcAlpha,a.dstFactor=GPUBlendFactor.One,a.operation=GPUBlendOperation.Add;break;case SubtractiveBlending:a.srcFactor=GPUBlendFactor.Zero,a.dstFactor=!0===r?GPUBlendFactor.Zero:GPUBlendFactor.OneMinusSrcColor,a.operation=GPUBlendOperation.Add;break;case MultiplyBlending:a.srcFactor=GPUBlendFactor.Zero,a.dstFactor=GPUBlendFactor.SrcColor,a.operation=GPUBlendOperation.Add;break;case CustomBlending:a.srcFactor=this._getBlendFactor(e.blendSrc),a.dstFactor=this._getBlendFactor(e.blendDst),a.operation=this._getBlendOperation(e.blendEquation);break;default:console.error("THREE.WebGPURenderer: Blending not supported.",t)}return a}_getColorWriteMask(e){return!0===e.colorWrite?GPUColorWriteFlags.All:GPUColorWriteFlags.None}_getDepthCompare(e){let t;if(!1===e.depthTest)t=GPUCompareFunction.Always;else{const r=e.depthFunc;switch(r){case NeverDepth:t=GPUCompareFunction.Never;break;case AlwaysDepth:t=GPUCompareFunction.Always;break;case LessDepth:t=GPUCompareFunction.Less;break;case LessEqualDepth:t=GPUCompareFunction.LessEqual;break;case EqualDepth:t=GPUCompareFunction.Equal;break;case GreaterEqualDepth:t=GPUCompareFunction.GreaterEqual;break;case GreaterDepth:t=GPUCompareFunction.Greater;break;case NotEqualDepth:t=GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid depth function.",r)}}return t}_getPrimitiveState(e,t,r){const a={};if(a.topology=this._utils.getPrimitiveTopology(e,r),!0===e.isLine&&!0!==e.isLineSegments){const e=t.index?t.index.count:t.attributes.position.count;a.stripIndexFormat=e>65535?GPUIndexFormat.Uint32:GPUIndexFormat.Uint16}switch(r.side){case FrontSide:a.frontFace=GPUFrontFace.CW,a.cullMode=GPUCullMode.Front;break;case BackSide:a.frontFace=GPUFrontFace.CW,a.cullMode=GPUCullMode.Back;break;case DoubleSide:a.frontFace=GPUFrontFace.CW,a.cullMode=GPUCullMode.None;break;default:console.error("THREE.WebGPURenderer: Unknown Material.side value.",r.side)}return a}_getStencilCompare(e){let t;const r=e.stencilFunc;switch(r){case NeverStencilFunc:t=GPUCompareFunction.Never;break;case AlwaysStencilFunc:t=GPUCompareFunction.Always;break;case LessStencilFunc:t=GPUCompareFunction.Less;break;case LessEqualStencilFunc:t=GPUCompareFunction.LessEqual;break;case EqualStencilFunc:t=GPUCompareFunction.Equal;break;case GreaterEqualStencilFunc:t=GPUCompareFunction.GreaterEqual;break;case GreaterStencilFunc:t=GPUCompareFunction.Greater;break;case NotEqualStencilFunc:t=GPUCompareFunction.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid stencil function.",r)}return t}_getStencilOperation(e){let t;switch(e){case KeepStencilOp:t=GPUStencilOperation.Keep;break;case ZeroStencilOp:t=GPUStencilOperation.Zero;break;case ReplaceStencilOp:t=GPUStencilOperation.Replace;break;case InvertStencilOp:t=GPUStencilOperation.Invert;break;case IncrementStencilOp:t=GPUStencilOperation.IncrementClamp;break;case DecrementStencilOp:t=GPUStencilOperation.DecrementClamp;break;case IncrementWrapStencilOp:t=GPUStencilOperation.IncrementWrap;break;case DecrementWrapStencilOp:t=GPUStencilOperation.DecrementWrap;break;default:console.error("THREE.WebGPURenderer: Invalid stencil operation.",t)}return t}_getVertexFormat(e){const{itemSize:t,normalized:r}=e,a=e.array.constructor,n=e.constructor;let o;if(1==t)o=typeArraysToVertexFormatPrefixForItemSize1.get(a);else{const e=(typedAttributeToVertexFormatPrefix.get(n)||typedArraysToVertexFormatPrefix.get(a))[r?1:0];if(e){const r=a.BYTES_PER_ELEMENT*t,n=4*Math.floor((r+3)/4)/a.BYTES_PER_ELEMENT;if(n%1)throw new Error("THREE.WebGPURenderer: Bad vertex format item size.");o=`${e}x${n}`}}return o||console.error("THREE.WebGPURenderer: Vertex format not supported yet."),o}_getShaderAttributes(e,t){const r=e.attributes,a=[];for(let e=0;e<r.length;e++){const n=r[e].name,o=t.getAttribute(n),c=o.array.BYTES_PER_ELEMENT,l=this._getVertexFormat(o);let i=o.itemSize*c,s=0;!0===o.isInterleavedBufferAttribute&&(i=o.data.stride*c,s=o.offset*c),a.push({name:n,arrayStride:i,offset:s,format:l,slot:e})}return a}}export default WebGPURenderPipeline;