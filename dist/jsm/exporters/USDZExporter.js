import{DoubleSide}from"three";import*as fflate from"../libs/fflate.module.js";class USDZExporter{async parse(t,n={}){n=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}}},n);const e={},r="model.usda";e[r]=null;let o=buildHeader();o+=buildSceneStart(n);const i={},a={};t.traverseVisible((t=>{if(t.isMesh){const n=t.geometry,r=t.material;if(r.isMeshStandardMaterial){const a="geometries/Geometry_"+n.id+".usd";if(!(a in e)){const t=buildMeshObject(n);e[a]=buildUSDFileAsString(t)}r.uuid in i||(i[r.uuid]=r),o+=buildXform(t,n,r)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",t)}else t.isCamera&&(o+=buildCamera(t))})),o+=buildSceneEnd(),o+=buildMaterials(i,a),e[r]=fflate.strToU8(o),o=null;for(const t in a){const n=a[t],r=t.split("_")[1],o=1023===n.format,i=imageToCanvas(n.image,r,n.flipY),s=await new Promise((t=>i.toBlob(t,o?"image/png":"image/jpeg",1)));e[`textures/Texture_${t}.${o?"png":"jpg"}`]=new Uint8Array(await s.arrayBuffer())}let s=0;for(const t in e){const n=e[t];s+=34+t.length;const r=63&s;if(4!==r){const o=new Uint8Array(64-r);e[t]=[n,{extra:{12345:o}}]}s=n.length}return fflate.zipSync(e,{level:0})}}function imageToCanvas(t,n,e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const r=1024/Math.max(t.width,t.height),o=document.createElement("canvas");o.width=t.width*Math.min(1,r),o.height=t.height*Math.min(1,r);const i=o.getContext("2d");if(!0===e&&(i.translate(0,o.height),i.scale(1,-1)),i.drawImage(t,0,0,o.width,o.height),void 0!==n){const t=parseInt(n,16),e=(t>>16&255)/255,r=(t>>8&255)/255,a=(255&t)/255,s=i.getImageData(0,0,o.width,o.height),u=s.data;for(let t=0;t<u.length;t+=4)u[t+0]=u[t+0]*e,u[t+1]=u[t+1]*r,u[t+2]=u[t+2]*a;i.putImageData(s,0,0)}return o}throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const PRECISION=7;function buildHeader(){return'#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n'}function buildSceneStart(t){return`def Xform "Root"\n{\n    def Scope "Scenes" (\n        kind = "sceneLibrary"\n    )\n    {\n        def Xform "Scene" (\n            customData = {\n                bool preliminary_collidesWithEnvironment = 0\n                string sceneName = "Scene"\n            }\n            sceneName = "Scene"\n        )\n        {\n        token preliminary:anchoring:type = "${t.ar.anchoring.type}"\n        token preliminary:planeAnchoring:alignment = "${t.ar.planeAnchoring.alignment}"\n\n`}function buildSceneEnd(){return"\n        }\n    }\n}\n\n"}function buildUSDFileAsString(t){let n=buildHeader();return n+=t,fflate.strToU8(n)}function buildXform(t,n,e){const r="Object_"+t.id,o=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),`def Xform "${r}" (\n    prepend references = @./geometries/Geometry_${n.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${o}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${e.id}>\n}\n\n`}function buildMatrix(t){const n=t.elements;return`( ${buildMatrixRow(n,0)}, ${buildMatrixRow(n,4)}, ${buildMatrixRow(n,8)}, ${buildMatrixRow(n,12)} )`}function buildMatrixRow(t,n){return`(${t[n+0]}, ${t[n+1]}, ${t[n+2]}, ${t[n+3]})`}function buildMeshObject(t){return`\ndef "Geometry"\n{\n  ${buildMesh(t)}\n}\n`}function buildMesh(t){const n=t.attributes,e=n.position.count;return`\n    def Mesh "Geometry"\n    {\n        int[] faceVertexCounts = [${buildMeshVertexCount(t)}]\n        int[] faceVertexIndices = [${buildMeshVertexIndices(t)}]\n        normal3f[] normals = [${buildVector3Array(n.normal,e)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${buildVector3Array(n.position,e)}]\n        float2[] primvars:st = [${buildVector2Array(n.uv,e)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`}function buildMeshVertexCount(t){const n=null!==t.index?t.index.count:t.attributes.position.count;return Array(n/3).fill(3).join(", ")}function buildMeshVertexIndices(t){const n=t.index,e=[];if(null!==n)for(let t=0;t<n.count;t++)e.push(n.getX(t));else{const n=t.attributes.position.count;for(let t=0;t<n;t++)e.push(t)}return e.join(", ")}function buildVector3Array(t,n){if(void 0===t)return console.warn("USDZExporter: Normals missing."),Array(n).fill("(0, 0, 0)").join(", ");const e=[];for(let n=0;n<t.count;n++){const r=t.getX(n),o=t.getY(n),i=t.getZ(n);e.push(`(${r.toPrecision(PRECISION)}, ${o.toPrecision(PRECISION)}, ${i.toPrecision(PRECISION)})`)}return e.join(", ")}function buildVector2Array(t,n){if(void 0===t)return console.warn("USDZExporter: UVs missing."),Array(n).fill("(0, 0)").join(", ");const e=[];for(let n=0;n<t.count;n++){const r=t.getX(n),o=t.getY(n);e.push(`(${r.toPrecision(PRECISION)}, ${1-o.toPrecision(PRECISION)})`)}return e.join(", ")}function buildMaterials(t,n){const e=[];for(const r in t){const o=t[r];e.push(buildMaterial(o,n))}return`def "Materials"\n{\n${e.join("")}\n}\n\n`}function buildMaterial(t,n){const e="            ",r=[],o=[];function i(e,r,o){const i=e.id+(o?"_"+o.getHexString():""),a=1023===e.format;return n[i]=e,`\n        def Shader "Transform2d_${r}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${t.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${buildVector2(e.repeat)}\n            float2 inputs:translation = ${buildVector2(e.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${e.id}_${r}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${i}.${a?"png":"jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${r}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n            ${t.transparent||t.alphaTest>0?"float outputs:a":""}\n        }`}return t.side===DoubleSide&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t),null!==t.map?(r.push(`${e}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?r.push(`${e}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(r.push(`${e}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),r.push(`${e}float inputs:opacityThreshold = ${t.alphaTest}`)),o.push(i(t.map,"diffuse",t.color))):r.push(`${e}color3f inputs:diffuseColor = ${buildColor(t.color)}`),null!==t.emissiveMap?(r.push(`${e}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`),o.push(i(t.emissiveMap,"emissive"))):t.emissive.getHex()>0&&r.push(`${e}color3f inputs:emissiveColor = ${buildColor(t.emissive)}`),null!==t.normalMap&&(r.push(`${e}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),o.push(i(t.normalMap,"normal"))),null!==t.aoMap&&(r.push(`${e}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`),o.push(i(t.aoMap,"occlusion"))),null!==t.roughnessMap&&1===t.roughness?(r.push(`${e}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`),o.push(i(t.roughnessMap,"roughness"))):r.push(`${e}float inputs:roughness = ${t.roughness}`),null!==t.metalnessMap&&1===t.metalness?(r.push(`${e}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`),o.push(i(t.metalnessMap,"metallic"))):r.push(`${e}float inputs:metallic = ${t.metalness}`),null!==t.alphaMap?(r.push(`${e}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),r.push(`${e}float inputs:opacityThreshold = 0.0001`),o.push(i(t.alphaMap,"opacity"))):r.push(`${e}float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial&&(r.push(`${e}float inputs:clearcoat = ${t.clearcoat}`),r.push(`${e}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`),r.push(`${e}float inputs:ior = ${t.ior}`)),`\n    def Material "Material_${t.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${t.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${o.join("\n")}\n\n    }\n`}function buildColor(t){return`(${t.r}, ${t.g}, ${t.b})`}function buildVector2(t){return`(${t.x}, ${t.y})`}function buildCamera(t){const n=t.name?t.name:"Camera_"+t.id,e=buildMatrix(t.matrixWorld);return t.matrixWorld.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t),t.isOrthographicCamera?`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\t\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(PRECISION)}, ${t.far.toPrecision(PRECISION)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.left)+Math.abs(t.right))).toPrecision(PRECISION)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.top)+Math.abs(t.bottom))).toPrecision(PRECISION)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`:`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${e}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\t\n\t\t\tfloat2 clippingRange = (${t.near.toPrecision(PRECISION)}, ${t.far.toPrecision(PRECISION)})\n\t\t\tfloat focalLength = ${t.getFocalLength().toPrecision(PRECISION)}\n\t\t\tfloat focusDistance = ${t.focus.toPrecision(PRECISION)}\n\t\t\tfloat horizontalAperture = ${t.getFilmWidth().toPrecision(PRECISION)}\n\t\t\ttoken projection = "perspective"\n\t\t\tfloat verticalAperture = ${t.getFilmHeight().toPrecision(PRECISION)}\n\t\t}\n\t\n\t`}export{USDZExporter};